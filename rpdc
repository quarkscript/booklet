#!/bin/bash
printhelp(){ 
    echo "
##      Rasterized Pdf or Djvu Combiner (rpdc) - shell scripts for
## make booklets, split double pages, apply imagemagick filters and so on
## ====Requires==============================================================
## bash like shell + basic core-tools like: echo, head, tail, ls, sed, grep,
## sort, cat, less, wc... + gs, djvu-libre, imagemagick, potrace, pdftoppm
## ====Use===================================================================
## $0 [par1 par2 ... or [-h,--help]]   (sequence is not important):
## ==========================================================================
## infile=filename_of_your_document.[pdf,djvu]                     (required)
## do not use in filename spaces or special symbols like '*!#+=@
## --------------------------------------------------------------------------
## [outfile=book.[pdf,djvu]]  book.djvu by default
## --------------------------------------------------------------------------
## [pages=10] count of pages to process, all available by default
## ====pages=layout==============================(one=function=per=pass)=====
##        split2p/glue2p                   booklet
##      -----     --- ---     --- --- --- ---   ----- -----
##      |1|2| >/< |1|+|2|     |1|+|2|+|3|+|4| > |4|1|+|2|3|
##      -----     --- ---     --- --- --- ---   ----- -----
## --------------------------------------------------------------------------    
## [split2p,split2p=100] split each page to right and left pages
## =100 - set pixels of overlap, 0 by default
## --------------------------------------------------------------------------
## [glue2p] reverse of split2p, but overlap do not implemented here
## --------------------------------------------------------------------------
## [booklet] make simple booklet, empty extra pages will be added (when need)
## Print reversed even pages of output document to back side, print odd pages 
## of output document to face side and you got a simple paper booklet
## --------------------------------------------------------------------------
## [cbook=16] complex booklet, 16 (def) - period in pages; print in same way 
## as a simple booklet and you got a complex booklet with specified period
## ====imagemagick=filters===================================================
## [rotate=0] (default) in degrees; 90 -90 15 and so on
## --------------------------------------------------------------------------
## [magick=[...]] apply imagemagick filters, for example
## magick=[-auto-gamma -adaptive-blur 3 -gamma 1.2 -brightness-contrast 0x70]
## ====extra=parameters======================================================
## [room=10-5] make extra 5 free 'slots' from 10th page
## This make sense only in filter pass and manual interventional after
## --------------------------------------------------------------------------
## [calc_pages] just calculate amount of pages that is it
## --------------------------------------------------------------------------
## [region=3-10] extract 10 pages from 3d, no any processing
## ----djvu-specific-option--------------------------------------------------
## [force-photo] djvu-out parameter, means encode all pages as photo
## ----pdf-specific-options--------------------------------------------------
## [pdftoppm,inkscape] use pdftoppm or inkscape instead of gs to extract 
## ----pdf-gs-specific-options-----------------------------------------------
## [pdfdpi=300] (default) resolution for pdf rasterization with gs
## --------------------------------------------------------------------------
## [pngmono, pnggray, png16, png256, png16m] - pdf rast. color space for gs
## monochrome, 8-bit gray, 4-bit color, 8-bit color (default), 24-bit color
## --------------------------------------------------------------------------
## [potrace] convert grayscale pages to monochrome and vectorize it
## --------------------------------------------------------------------------
## [pdfrsm] reassamble pdf file
## ----multipass-use-options-------------------------------------------------
## [stage-extract,stage-filter,stage-mux] for run in couple passes and make
## complex processing, for example split2p then rotate then booklet
## ----performance-option----------------------------------------------------
## [proc=4] set limit of simultaneous processes, max by default 
## proc. multiply not only used cpu cores but used memory too, be aware
## ----debug-----------------------------------------------------------------
## [selfsomedebugon,selfsomedebugoff] mod this script to hide/unhide warnings
## --------------------------------------------------------------------------
#############################################################################
##                                                                          #
## There are not all checks. Fails possible.                                #
## Author/dev. Andrew S. [github,gitlab].com/quarkscript/ Licence GPL       #
##                                                                          #
#############################################################################
## press 'q' to exit from help
" 
}

c_t_c(){
    ## calc process count; $1 - each process mem footprint $2 multiplier
    if [ -z $2 ]; then
        tmpvar11=8
    else
        tmpvar11=$2
    fi
    tmpvar10=$(echo $(($(echo $(echo $(free) | sed 's/ Swap.*//g' | sed 's/.* //g'))/1024))) # available ram
    tmpvar12=$(($(grep 'model name' /proc/cpuinfo --count)+0)) # amount of cpus
    if [ -z "$1" ]; then
        tmpvar8=$(identify "work_dir/$(ls work_dir/ | grep png | head -n 1)")
        tmpvar9=$(($(echo $tmpvar8 | sed 's/.* PNG //g' | sed 's/ .*//g' | sed 's/x.*//g')*$(echo $tmpvar8 | sed 's/.* PNG //g' | sed 's/ .*//g' | sed 's/.*x//g')*64/(8*1024*1024))) # uncompressed image size where 1 pixel is 8 bytes
        if [ $tmpvar9 -eq 0 ]; then
            tmpvar9=1
        fi
        
        if [ "$(($tmpvar10*9/10))" -ge "$(($tmpvar9*($tmpvar12+1)*16))" ]; then
            memfp="$(($tmpvar10*9/(10*($tmpvar12+1))))"
            limits=" -limit memory $(($memfp+0))M -limit map 0M"
        elif [ "$(($tmpvar10*9/10))" -ge "$(($tmpvar9*$tmpvar12*10))" ]; then
            memfp="$(($tmpvar9*10))"
            limits=" -limit memory $(($memfp+0))M -limit map 0M"
        elif [ "$(($tmpvar10*9/10))" -ge "$(($tmpvar9*$tmpvar12*$tmpvar11))" ]; then
            memfp="$(($tmpvar9*$tmpvar11))"
            limits=" -limit memory $(($memfp+0))M -limit map 0M"
        elif [ "$(($tmpvar10*9/(10*2)))" -ge "$(($tmpvar9*$tmpvar11))" ]; then
            memfp="$(($tmpvar9*$tmpvar11))"
            limits=" -limit memory $(($memfp+0))M -limit map 0M"
        else
        #elif $(echo $(df /tmp) | grep -vq tmpfs); then
            limits=" -limit memory $(($tmpvar10*9/10))M -limit map 0M"
            memfp="$(($tmpvar10*9/10))"
        #else
        #    limits="-limit proc 1 -limit memory 256M -limit map 0M"
        #    memfp=256
        fi
    else
        memfp=$1
        limits=""
    fi
    
    tmpvar5=$((tmpvar10/$memfp))
    if [ -n "$tmpvar5" ]; then
        if $(echo $inargs | grep -q 'proc=' )&&[ "$(echo $inargs | sed 's/.*proc=//g' | sed 's/ .*//g')" -le "$tmpvar5" ]; then
            procs=$(echo $inargs | sed 's/.*proc=//g' | sed 's/ .*//g')
        elif [ "$tmpvar5" -gt 0 ]; then 
            if [ "$tmpvar5" -ge "$(($tmpvar12+1))" ]; then
                procs=$(($tmpvar12+1))
            else
                procs=$tmpvar5
            fi
        else
            procs=1
        fi
    else
        procs=1
    fi
    #echo " -diagnostic-msg- memfp=$memfp Mb proc=$procs image size up lim $tmpvar9 Mb cpu cores $tmpvar12"
    }

activmon(){
    prsy[0]='# /'; prsy[1]='# -'; prsy[2]='# \'; prsy[3]='# |'
    echo -en "\r${prsy[$((10#$(date | sed 's/.*://g' | sed 's/ .*//g')%4))]}"
    echo -en "\r"
    }
    
trp(){
    ## procs (process) processing
    procscount=$(($procscount+1))
    if [ "$procscount" -ge "$procs" ]; then procscount=0; activmon & 
    wait; fi
    }

inargs=$(echo $@)

if $(Xdialog --version 2>&1 | grep -vq 'command not found') && [ -z "$inargs" ]; then 
    dialogapp=Xdialog
    selectdocument(){
        var_len_dialog="$dialogapp --title "'"Simple pseudo gui of '$0'" --no-cancel --radiolist "Specify document to process\nfilename must not contain spaces or special symbols, otherwise script fails" '"'38' '100' '' "    
        tmpfile33=$(mktemp XXXXXXXX.tmp)
        ls -1 --hide=*.tmp --hide=$(echo $0 | sed 's|./||g') | grep --regexp='.pdf' --regexp='.djv' | sed "s/'//g" | sed 's/"//g' >$tmpfile33
        for ((cyclevar3=1;cyclevar3<=$(wc -l $tmpfile33 | sed 's/ .*//g');cyclevar3+=1)); do
            var_len_dialog+="'$(cat $tmpfile33 | head -n +$cyclevar3 | tail -n 1)' '' '' "
        done
        var_len_dialog+=' 2>'"$dialog_exitstatus"
        eval "$var_len_dialog"
        run_command+="infile=$(cat $dialog_exitstatus | tail -n 1 ) "
        rm -f $tmpfile33
    }

    dialog_exitstatus=$(mktemp XXXXXXXX.tmp)
    clear
    
    run_command="$0 "
    $dialogapp --title "Simple pseudo gui of $0" --radiolist 'Rasterized Pdf or Djvu Combiner (rpdc) - shell scripts for\nmake booklets, split double pages, apply imagemagick filters and so on\n\nAuthor/dev. Andrew S.   https://git[hu,la]b.com/quarkscript/      Licence GPL' '28' '100' '' 'default' 'split->filter->mux pdf/djvu document' 'on' 'pdfrsm' 'reassemble pdf with gs' '' 'calc_pages' '' '' 'region' 'extract X pages start at Y page' ''  2>"$dialog_exitstatus"
    
    if [ -z "$(cat $dialog_exitstatus | tail -n 1 )" ]; then
        rm -f $dialog_exitstatus
        exit 0
    fi
    
    if [ $(cat $dialog_exitstatus | wc -l) -gt 1 ]; then
        $dialogapp --title 'Unexpected events' --no-cancel --msgbox "It looks like some errors or warnings have occurred. This may interfere with gui. \nIf somethink fail you can fix the problems and try this script again or run it without a gui \n\n$(cat $dialog_exitstatus | head -n $(($(cat $dialog_exitstatus | wc -l)-1)) )\n" '' ''
        #exit 1
    fi
    
    if $(cat $dialog_exitstatus | tail -n 1  | grep -vq --regexp='default' --regexp='region'); then
        run_command+="$(cat $dialog_exitstatus | tail -n 1 ) "
    fi
    
    if $(cat $dialog_exitstatus | tail -n 1  | grep -q 'default'); then
        
        $dialogapp --title "Simple pseudo gui of $0" --no-cancel --checklist 'Select required stages or leave all empty for default' '20' '80' '' 'stage-extract' 'split pages to single raster pictures' '' 'stage-filter' 'make booklet or apply an imagemagick filters or so on' '' 'stage-mux' 'assemble pages to output djvu or pdf document' '' 2>"$dialog_exitstatus"
        
        tmpvar6=$(cat $dialog_exitstatus | tail -n 1  | sed 's|\/| |g')
        
        run_command+="$(echo $tmpvar6) "
        if $(echo $tmpvar6 | grep -q stage-extract) || [ -z "$tmpvar6" ]; then
            
            selectdocument
            
            if $(cat $dialog_exitstatus | tail -n 1  | grep -q '.pdf'); then
                $dialogapp --title "Simple pseudo gui of $0" --no-cancel --radiolist 'Specify an engine to rasterize pdf' '18' '40' '' 'gs' '' '' 'pdftoppm' '' '' 'inkscape' '' ''  2>"$dialog_exitstatus"
                if $(cat $dialog_exitstatus | tail -n 1  | grep -vq 'gs'); then
                    run_command+="$(cat $dialog_exitstatus | tail -n 1 ) "
                else
                    $dialogapp --title "Simple pseudo gui of $0" --no-cancel --radiolist 'Specify a color space' '20' '40' '' 'pngmono' 'monochrome' '' 'pnggray' '8-bit gray' '' 'png16' '4-bit color' '' 'png256' '8-bit color' 'on' 'png16m' '24-bit color' ''  2>"$dialog_exitstatus"
                    run_command+="$(cat $dialog_exitstatus | tail -n 1 ) "
                    $dialogapp --title "Simple pseudo gui of $0" --no-cancel --inputbox 'Specify images resolution in dpi' '10' '50' '300' 2>"$dialog_exitstatus"
                    run_command+="pdfdpi=$(cat $dialog_exitstatus | tail -n 1 ) "
                fi
            fi
            
            $dialogapp --title "Simple pseudo gui of $0" --no-cancel --inputbox 'Specify pages count or leave empty\nto process all available' '10' '50' '' 2>"$dialog_exitstatus"
            if $(cat $dialog_exitstatus | tail -n 1  | grep -q [0-9]); then
                run_command+="pages=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g') "
            fi
        fi
        if $(echo $tmpvar6 | grep -q stage-filter) || [ -z "$tmpvar6" ]; then
            
            $dialogapp --title "Simple pseudo gui of $0" --no-cancel --inputbox 'Specify rotate angle\nit will be applied any way' '10' '50' '0' 2>"$dialog_exitstatus"
            run_command+="rotate=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g') "
            
            $dialogapp --title "Simple pseudo gui of $0" --no-cancel --radiolist 'Specify a filter or sheme' '24' '80' '' 'none' '' 'on' 'split2p' '|1|2| > |1|+|2| or |1/2| > |1|+|2|' '' 'glue2p' '|1|+|2| > |1|2| or |1|+|2| > |1/2|' '' 'booklet' '|1|+|2|+|3|+|4| > |4|1|+|2|3|' '' 'cbook' 'make complex booklet' '' 'magick' 'apply custom imagemagick filters' '' 'room' 'make extra free slots for manual intervention' '' 2>"$dialog_exitstatus"
            
            tmpvar7=$(cat $dialog_exitstatus | tail -n 1 )
            if [ "$tmpvar7" == "split2p" ]; then
                $dialogapp --title "Simple pseudo gui of $0" --no-cancel --inputbox 'Specify overlap pixels\npositive or negative' '10' '50' '0' 2>"$dialog_exitstatus"
                run_command+="split2p=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g') "
            elif [ "$tmpvar7" == "cbook" ]; then
                $dialogapp --title "Simple pseudo gui of $0" --no-cancel --inputbox 'Specify period in pages' '10' '50' '16' 2>"$dialog_exitstatus"
                run_command+="cbook=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g') "
            elif [ "$tmpvar7" == "magick" ]; then
                $dialogapp --title "Simple pseudo gui of $0" --no-cancel --inputbox 'Specify imagemagick filters like\n-auto-gamma -adaptive-blur 3 -gamma 1.2 -brightness-contrast 0x70' '10' '100' '' 2>"$dialog_exitstatus"
                run_command+="magick=[$(cat $dialog_exitstatus | tail -n 1 )] "
            elif [ "$tmpvar7" == "room" ]; then
                $dialogapp --title "Simple pseudo gui of $0" --no-cancel --inputbox 'Specify start position for manual insert pages' '10' '60' '' 2>"$dialog_exitstatus"
                run_command+="room=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g')-"
                $dialogapp --title "Simple pseudo gui of $0" --no-cancel --inputbox 'Specify count of manual inserted pages' '10' '60' '' 2>"$dialog_exitstatus"
                run_command+="$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g') "
            else
                run_command+="$(cat $dialog_exitstatus | tail -n 1 )"
            fi
        fi
        if $(echo $tmpvar6 | grep -q stage-mux) || [ -z "$tmpvar6" ]; then
            $dialogapp --title "Simple pseudo gui of $0" --no-cancel --inputbox 'Enter output file (pdf or djvu)' '10' '50' 'book.djvu' 2>"$dialog_exitstatus"
            run_command+="outfile=$(cat $dialog_exitstatus | tail -n 1 ) "
            if $(cat $dialog_exitstatus | tail -n 1  | grep -q '.djv'); then
                $dialogapp --title "Simple pseudo gui of $0" --no-cancel --checklist 'You may encode grayscale and \nmonochrome pages as photo' '12' '50' '' 'force-photo' '' ''  2>"$dialog_exitstatus"
                run_command+="$(cat $dialog_exitstatus | tail -n 1 ) "
            elif $(cat $dialog_exitstatus | tail -n 1  | grep -q '.pdf'); then
                $dialogapp --title "Simple pseudo gui of $0" --no-cancel --checklist 'You may trace all pages to monochrome vector images \n(not recommended, but may be useful for shemes an so on)' '12' '80' '' 'potrace' '' ''  2>"$dialog_exitstatus"
                run_command+="$(cat $dialog_exitstatus | tail -n 1 ) "
            fi
        fi
        $dialogapp --title "Simple pseudo gui of $0" --no-cancel --radiolist "Specify some resources limits.\nMemory footprint is depends on \n image size and amount of processes.\n\nDon't forget to check results! \n" '24' '50' '' '1' 'process' '' '2' 'or less processes' '' '4' 'or less processes' '' 'max' 'available processes' 'on'  2>"$dialog_exitstatus"
        if $(cat "$dialog_exitstatus" | tail -n 1  | grep -vq max); then
            run_command+=" proc=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g') "
        fi
        
    elif $(cat $dialog_exitstatus | tail -n 1  | grep -q 'pdfrsm'); then
        selectdocument
    elif $(cat $dialog_exitstatus | tail -n 1  | grep -q 'calc_pages'); then
        selectdocument
    elif $(cat $dialog_exitstatus | tail -n 1  | grep -q 'region'); then
        selectdocument
        $dialogapp --title "Simple pseudo gui of $0" --no-cancel --inputbox 'Specify start position of exported pages' '10' '60' '' 2>"$dialog_exitstatus"
        run_command+="region=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g')-"
        $dialogapp --title "Simple pseudo gui of $0" --no-cancel --inputbox 'Specify count of exported pages' '10' '60' '' 2>"$dialog_exitstatus"
        run_command+="$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g') "
        
        $dialogapp --title "Simple pseudo gui of $0" --no-cancel --inputbox 'Enter output file name\n(no spaces or special symbols)' '10' '50' '' 2>"$dialog_exitstatus"
        run_command+="outfile=$(cat $dialog_exitstatus | tail -n 1 ) "
    fi
    
    rm -f $dialog_exitstatus
    clear
    echo $run_command
    if $(echo $run_command | grep -q calc_pages); then
        $dialogapp --title 'Pages' --no-cancel --msgbox "\nThere are $(eval "$run_command" | tail -n 1) page(s)\n" '' ''
    else
        $dialogapp --title 'execution log without warnings' --no-cancel --msgbox "\n$(echo $(eval "$run_command" 2>&1 | sed 's@# [\\/|-]@@g' | sed 's/  //g'))\n" '' ''
        #eval "$run_command" 
    fi
    exit 0

elif $(kdialog --version 2>&1 | grep -vq 'command not found') && [ -z "$inargs" ]; then
    dialogapp=kdialog
    check_status(){
        if [ -z "$(cat "$dialog_exitstatus")" ]; then
            $dialogapp --title 'Script termination message' --msgbox 'Nothing specified\nScript terminated'
            rm -f $dialog_exitstatus
            exit 1
        fi
    }
    selectdocument(){
        var_len_dialog="$dialogapp --title "'"Simple pseudo gui of '$0'" --combobox "Specify document to process\nfilename must not contain spaces or special symbols, \notherwise script may fails" '" " 
        chkvar1="$var_len_dialog"
        tmpfile33=$(mktemp XXXXXXXX.tmp)
        echo ''>"$dialog_exitstatus"
        ls -1 --hide=*.tmp --hide=$(echo $0 | sed 's|./||g') | grep --regexp='.pdf' --regexp='.djv' | sed "s/'//g" | sed 's/"//g' >$tmpfile33
        for ((cyclevar3=1;cyclevar3<=$(wc -l $tmpfile33 | sed 's/ .*//g');cyclevar3+=1)); do
            var_len_dialog+="'$(cat $tmpfile33 | head -n +$cyclevar3 | tail -n 1)' "
        done
        if [ "$chkvar1" == "$var_len_dialog" ]; then
            $dialogapp --title "Simple pseudo gui of $0" --msgbox '"djvu" or "pdf" files not found\nplace document to current dir\nand try again'
            rm -f $tmpfile33
            exit 1
        fi
        var_len_dialog+=' 1>'"$dialog_exitstatus"
        eval "$var_len_dialog"
        run_command+="infile=$(cat $dialog_exitstatus | tail -n 1 ) "
        rm -f $tmpfile33
        check_status
    }

    dialog_exitstatus=$(mktemp XXXXXXXX.tmp)
    clear
    
    run_command="$0 "
    $dialogapp --title "Simple pseudo gui of $0" --combobox 'Rasterized Pdf or Djvu Combiner (rpdc) - shell scripts for\nmake booklets, split double pages, apply imagemagick filters and so on\n\nAuthor/dev. Andrew S.   https://git[la,hu]b.com/quarkscript/ Licence GPL\n\nSpecify next action' 'split->filter->mux pdf/djvu document' 'reassemble pdf with ghostscript' 'calc pages of document' 'extract X pages start at Y page' --default 'split->filter->mux pdf/djvu document'  1>"$dialog_exitstatus"
    check_status
    
    if $(cat "$dialog_exitstatus" | grep -q reassemble); then
        run_command+="pdfrsm "
        selectdocument
    elif $(cat "$dialog_exitstatus" | grep -q calc); then
        run_command+="calc_pages "
        selectdocument
    elif $(cat "$dialog_exitstatus" | grep -q extract); then
        selectdocument
        echo ''>$dialog_exitstatus
        $dialogapp --title "Simple pseudo gui of $0" --inputbox 'Specify start position of exported pages' '1' 1>"$dialog_exitstatus"
        run_command+="region=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g')-"
        check_status
        echo ''>$dialog_exitstatus
        $dialogapp --title "Simple pseudo gui of $0" --inputbox 'Specify count of exported pages' '1' 1>"$dialog_exitstatus"
        run_command+="$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g') "
        check_status
        echo ''>$dialog_exitstatus
        $dialogapp --title "Simple pseudo gui of $0" --inputbox 'Enter output file name\n(no spaces or special symbols)' '' 1>"$dialog_exitstatus"
        run_command+="outfile=$(cat $dialog_exitstatus | tail -n 1 ) "
        check_status
    elif $(cat "$dialog_exitstatus" | grep -q split); then
        echo ''>$dialog_exitstatus
        $dialogapp --title "Simple pseudo gui of $0" --combobox 'Select required stages' 'all stages' '1- split pages to single raster pictures' '2- make booklet or apply an imagemagick filters or so on' '3- assemble pages to output djvu or pdf document' --default 'all stages' 1>"$dialog_exitstatus"
        if $(cat $dialog_exitstatus | tail -n 1  | grep -q 'all stages'); then
            tmpvar6=''
        elif $(cat $dialog_exitstatus | tail -n 1  | grep -q '1-'); then
            tmpvar6='stage-extract'
        elif $(cat $dialog_exitstatus | tail -n 1  | grep -q '2-'); then
            tmpvar6='stage-filter'
        else
            tmpvar6='stage-mux'
        fi
        check_status
        run_command+="$(echo $tmpvar6) "
        if $(echo $tmpvar6 | grep -q stage-extract) || [ -z "$tmpvar6" ]; then
            selectdocument
            if $(cat $dialog_exitstatus | tail -n 1  | grep -q '.pdf'); then
                echo ''>$dialog_exitstatus
                $dialogapp --title "Simple pseudo gui of $0" --combobox 'Specify an engine to rasterize pdf' 'ghostscript' 'pdftoppm' 'inkscape' --default 'ghostscript' 1>"$dialog_exitstatus"
                check_status
                if $(cat $dialog_exitstatus | tail -n 1  | grep -vq 'ghostscript'); then
                    run_command+="$(cat $dialog_exitstatus | tail -n 1 ) "
                else
                    echo ''>$dialog_exitstatus
                    $dialogapp --title "Simple pseudo gui of $0" --combobox 'Specify a color space' 'monochrome' '8-bit gray' '4-bit color' '8-bit color' '24-bit color' --default '8-bit color'  1>"$dialog_exitstatus"
                    check_status
                    if $(cat $dialog_exitstatus | tail -n 1  | grep -q 'monochrome'); then
                        run_command+="pngmono "
                    elif $(cat $dialog_exitstatus | tail -n 1  | grep -q '8-bit gray'); then
                        run_command+="pnggray "
                    elif $(cat $dialog_exitstatus | tail -n 1  | grep -q '4-bit color'); then
                        run_command+="png16 "
                    elif $(cat $dialog_exitstatus | tail -n 1  | grep -q '8-bit color'); then
                        run_command+="png256 "
                    else
                        run_command+="png16m "
                    fi
                    echo ''>$dialog_exitstatus
                    $dialogapp --title "Simple pseudo gui of $0" --inputbox 'Specify images resolution in dpi' '300' 1>"$dialog_exitstatus"
                    run_command+="pdfdpi=$(cat $dialog_exitstatus | tail -n 1 ) "
                fi
            fi
            
            echo ''>$dialog_exitstatus
            $dialogapp --title "Simple pseudo gui of $0" --inputbox 'Specify pages count or leave empty\nto process all available' '' 1>"$dialog_exitstatus"
            if $(cat $dialog_exitstatus | tail -n 1  | grep -q [0-9]); then
                run_command+="pages=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g') "
            fi
        fi
        if $(echo $tmpvar6 | grep -q stage-filter) || [ -z "$tmpvar6" ]; then
            echo ''>$dialog_exitstatus
            $dialogapp --title "Simple pseudo gui of $0" --inputbox 'Specify rotate angle\n(it will be applied any way)' '0' 1>"$dialog_exitstatus"
            check_status
            run_command+="rotate=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g') "
            echo ''>$dialog_exitstatus
            $dialogapp --title "Simple pseudo gui of $0" --combobox 'Specify a filter or sheme' 'none' 'split: |1|2| > |1|+|2| or |1/2| > |1|+|2|' 'glue: |1|+|2| > |1|2| or |1|+|2| > |1/2|' 'booklet: |1|+|2|+|3|+|4| > |4|1|+|2|3|' 'make complex booklet' 'apply imagemagick filters' 'make extra free slots for manual intervention' --default 'none' 1>"$dialog_exitstatus"
            
            tmpvar7=$(cat $dialog_exitstatus | tail -n 1 )
            if [ "$tmpvar7" == "split: |1|2| > |1|+|2| or |1/2| > |1|+|2|" ]; then
                echo ''>$dialog_exitstatus
                $dialogapp --title "Simple pseudo gui of $0" --inputbox 'Specify overlap pixels\npositive or negative' '0' 1>"$dialog_exitstatus"
                run_command+="split2p=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g') "
            elif [ "$tmpvar7" == "glue: |1|+|2| > |1|2| or |1|+|2| > |1/2|" ]; then
                run_command+="glue2p "
            elif [ "$tmpvar7" == "make complex booklet" ]; then
                echo ''>$dialog_exitstatus
                $dialogapp --title "Simple pseudo gui of $0" --inputbox 'Specify period in pages' '16' 1>"$dialog_exitstatus"
                run_command+="cbook=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g') "
            elif [ "$tmpvar7" == "apply imagemagick filters" ]; then
                echo ''>$dialog_exitstatus
                $dialogapp --title "Simple pseudo gui of $0" --inputbox 'Specify imagemagick filters like\n-auto-gamma -adaptive-blur 3 -gamma 1.2 -brightness-contrast 0x70' '' 1>"$dialog_exitstatus"
                check_status
                run_command+="magick=[$(cat $dialog_exitstatus | tail -n 1 )] "
            elif [ "$tmpvar7" == "make extra free slots for manual intervention" ]; then
                echo ''>$dialog_exitstatus
                $dialogapp --title "Simple pseudo gui of $0" --inputbox 'Specify start position for manual insert pages' '' 1>"$dialog_exitstatus"
                run_command+="room=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g')-"
                check_status
                echo ''>$dialog_exitstatus
                $dialogapp --title "Simple pseudo gui of $0" --inputbox 'Specify count of manual inserted pages' '' 1>"$dialog_exitstatus"
                check_status
                run_command+="$(cat $dialog_exitstatus | tail -n 1  | sed 's/ //g') "                
            else
                run_command+="booklet "
            fi
        fi
        if $(echo $tmpvar6 | grep -q stage-mux) || [ -z "$tmpvar6" ]; then
            $dialogapp --title "Simple pseudo gui of $0" --inputbox 'Enter output file (pdf or djvu)' 'book.djvu' 1>"$dialog_exitstatus"
            check_status
            run_command+="outfile=$(cat $dialog_exitstatus | tail -n 1 ) "
            if $(cat $dialog_exitstatus | tail -n 1  | sed 's/.*\././g' | grep -q '.djv'); then
                $dialogapp --title "Simple pseudo gui of $0" --combobox 'You may encode grayscale and \nmonochrome pages as photo' 'encode as text' 'encode as photo' --default 'encode as text'  1>"$dialog_exitstatus"
                if $(cat $dialog_exitstatus | tail -n 1  | grep -q 'photo' ); then
                    run_command+="force-photo "
                fi
            elif $(cat $dialog_exitstatus | tail -n 1 | sed 's/.*\././g' | grep -q '.pdf'); then
                $dialogapp --title "Simple pseudo gui of $0" --combobox 'You may trace all pages to monochrome vector images \n(not recommended, but may be useful for shemes an so on)' 'do not trace' 'trace with potrace' --default 'do not trace'  1>"$dialog_exitstatus"
                if $(cat $dialog_exitstatus | tail -n 1  | grep -q 'potrace'); then
                    run_command+="potrace "
                fi
            fi
        fi
        $dialogapp --title "Simple pseudo gui of $0" --combobox "Memory footprint of each process is depend on image size.\nIn case run out of RAM you may lost some pages. So \n\ndon't forget to check results! Specify limit to" '1 process' '2 or less processes' '4 or less processes' 'max available processes' --default 'max available processes'  1>"$dialog_exitstatus"
        if $(cat "$dialog_exitstatus" | tail -n 1  | grep -vq max); then
            run_command+=" proc=$(cat $dialog_exitstatus | tail -n 1  | sed 's/ .*//g') "
        fi 
    fi
    
    rm -f $dialog_exitstatus
    clear
    echo $run_command
    if $(echo $run_command | grep -q calc_pages); then
        $dialogapp --title 'Pages' --msgbox "\nThere are $(eval "$run_command" | tail -n 1) page(s)\n" '' ''
    else
        $dialogapp --title 'execution log' --msgbox "\n$(eval "$run_command" 2>&1 | sed 's@# [\\/|-]@@g')\n" '' ''
        #eval "$run_command" 
    fi
    exit 0

elif [ -z "$inargs" ] || $(echo $inargs | grep -q --regexp='-h' --regexp='--help'); then
    if $(less -V 2>&1| grep -q 'command not found'); then
        printhelp; exit 0
    else
        printhelp | less; exit 0
    fi

fi

if $(echo $inargs | grep -q 'selfsomedebugon' ); then
    sed -i 's/2>\/dev\/null/#2>\/dev\/null/g' $(echo $0 | sed 's|.\/||g')
    sed -i 's/1>\/dev\/null/#1>\/dev\/null/g' $(echo $0 | sed 's|.\/||g')
    sed -i 's/-o \/dev\/null/) #-o \/dev\/null/g' $(echo $0 | sed 's|.\/||g')
    exit 0
elif $(echo $inargs | grep -q 'selfsomedebugoff' ); then
    sed -i 's/#2>\/dev\/null/2>\/dev\/null/g' $(echo $0 | sed 's|.\/||g')
    sed -i 's/#1>\/dev\/null/1>\/dev\/null/g' $(echo $0 | sed 's|.\/||g')
    sed -i 's/) #-o \/dev\/null/-o \/dev\/null/g' $(echo $0 | sed 's|.\/||g')
    exit 0
fi

## check for djvulibre installed
if $(echo $inargs | grep -q djv)&&$(djvused --help 2>&1| grep -q 'command not found')||$(echo $inargs | grep -vq outfile)&&$(echo $inargs | grep -vq --regexp='stage-extract' --regexp='stage-filter')&&$(djvused --help 2>&1| grep -q 'command not found'); then 
    echo seems djvulibre is not installed, it required for djvu proc.
    exit 0
fi
## check for ghostscript installed
if $(echo $inargs | grep -q pdf)&&$(gs -v 2>&1| grep -q 'command not found'); then 
    echo seems ghostscript is not installed, it required for pdf proc.
    exit 0
fi
## check for imagemagick installed
if $(magick -version 2>&1| grep -q 'command not found'); then 
    echo seems imagemagick is not installed, it required in any case
    exit 0
fi
## check for poppler installed
if $(echo $inargs | grep -q pdftoppm)&&$(pdftoppm -v 2>&1| grep -q 'command not found'); then 
    echo 'seems poppler (pdftoppm) is not installed, it required when specified'
    exit 0
fi
## check for inkscape installed
if $(echo $inargs | grep -q inkscape)&&$(inkscape -V 2>&1| grep -q 'command not found'); then 
    echo 'seems inkscape is not installed, it required when specified'
    exit 0
fi
## check for potrace installed
if $(echo $inargs | grep -q potrace)&&$(potrace -v 2>&1| grep -q 'command not found'); then 
    echo 'seems potrace is not installed, it required when specified'
    exit 0
fi

## lets say next doings may eat up to 512M of RAM for each process
c_t_c 512

if $(echo $inargs | grep -q 'outfile=' ); then
    outfile=$(echo $inargs | sed 's/.*outfile=//g' | sed 's/ .*//g')
else
    outfile=book.djvu
fi
if ($(echo $inargs | grep -q --regexp='stage-extract'))||($(echo $inargs | grep -vq --regexp='stage-')); then
    if $(echo $inargs | grep -q 'infile=' ); then
        infile=$(echo $inargs | sed 's/.*infile=//g' | sed 's/ .*//g')
        if [ ! -f $infile ]; then
            echo ''
            echo "File $infile not found, or its name contain spaces, symbols an so on.
            "; exit 0
        fi
    else
        echo ''
        echo Missing infile=filename argument. Try like 
        echo "$0 infile=your_pdf_or_djvu_file_name
        "; exit 0
    fi
    
    ## calc pages
    if $(echo $inargs | grep -q 'pages=' ); then
        pages=$(echo $inargs | sed 's/.*pages=//g' | sed 's/ .*//g')
    elif $(echo $infile | grep -iq '.djv'); then
        echo "# # # Get djvu pages count"
        pages=$(djvused -e "n" $infile)
    elif $(echo $infile | grep -iq '.pdf')&&$(echo $inargs | grep -vq 'pdf2ppm'); then
        echo "# # # Get pdf pages count"
        pages=$(gs -q -dNOSAFER -dNODISPLAY -dNumRenderingThreads=$procs -c "($infile) (r) file runpdfbegin pdfpagecount =" -f "$infile" -o /dev/null | sed 's/ .*//g')
    fi
    if $(echo $inargs | grep -q 'calc_pages'); then
        echo $pages
        exit 0
    fi
    ## extract a region of pages
    if $(echo $inargs | grep -q 'region='); then
        startpage=$(echo $inargs | sed 's/.*region=//g' | sed 's/-.*//g')
        pagescount=$(echo $inargs | sed "s/.*region=$startpage-//g" | sed 's/ .*//g')
        if [ "$(($startpage+$pagescount-1))" -gt "$pages" ]; then
            pagescount=$(($pages-$startpage+1))
        fi
        if $(echo $infile | grep -q pdf); then
            echo "# Extract pages (start at $startpage to $(($startpage+$pagescount-1))) from pdf" 
            gs -q -dNOSAFER -dNumRenderingThreads=$procs -sDEVICE=pdfwrite -o $(echo $outfile | sed 's/\..*//g').pdf -sPageList=$startpage-$(($startpage+$pagescount-1)) -f "$infile" 
            exit 0
        elif $(echo $infile | grep -q djv); then
            echo "# Extract region from djvu"
            cp "$infile" "$outfile"
            tmpvar1=$(($startpage+$pagescount))
            for ((cyclevar1=$pages; cyclevar1>=$tmpvar1; cyclevar1--)); do
                djvm -delete "$outfile" $cyclevar1
            done
            for ((cyclevar1=$startpage-1; cyclevar1>=1; cyclevar1--)); do
                djvm -delete "$outfile" $cyclevar1
            done
            exit 0
        else
            echo document formats except pdf and djvu are not supported
            exit 0
        fi
    fi
    ## reassamble pdf
    if $(echo $inargs | grep -q pdfrsm)&&$(echo $infile | grep -q '.pdf'); then
         echo "# Reassamble pdf"
         gs -o "rsm_$infile" -sDEVICE=pdfwrite -dNumRenderingThreads=$procs -f "$infile"
         exit 0
    fi
fi
if $(echo $inargs | grep -q 'pdfdpi=' ); then
    pdfdpi=$(echo $inargs | sed 's/.*pdfdpi=//g' | sed 's/ .*//g')
else
    pdfdpi=300
fi
if $(echo $inargs | grep -q 'rotate=' ); then
    rotate=$(echo $inargs | sed 's/.*rotate=//g' | sed 's/ .*//g')
else
    rotate=0
fi
if $(echo $inargs | grep -q 'pngmono' ); then pdfrastereng=pngmono
elif $(echo $inargs | grep -q 'pnggray' ); then pdfrastereng=pnggray
elif $(echo $inargs | grep -q 'png16m' ); then pdfrastereng=png16m
elif $(echo $inargs | grep -q 'png256' ); then pdfrastereng=png256
elif $(echo $inargs | grep -q 'png16' ); then pdfrastereng=png16
else pdfrastereng=png256; fi

#if $(echo $inargs | grep -q 'infile=' ); then

#else

#fi

## End of some checks
#######################
## Extract stage

if ($(echo $inargs | grep -vq 'stage-'))||($(echo $inargs | grep -q 'stage-extract')); then
    echo "# Extract stage"
    rm -fr work_dir
    mkdir work_dir
    if $(echo $infile | grep -q '.pdf')&&$(echo $inargs | grep -vq 'pdftoppm')&&$(echo $inargs | grep -vq 'inkscape'); then
    
        defpagesres=$(mktemp work_dir/XXXXX.tmp)

        echo "# ... Extract pages with gs"
        gs -dQUIET -dNOSAFER -dNODISPLAY -sFileName=$infile -c "FileName (r) file runpdfbegin 1 1 pdfpagecount {pdfgetpage /MediaBox get {=print ( ) print} forall (\n) print} for quit" > $defpagesres

        procscount=0
        for ((cyclevar1=1; cyclevar1<=$pages; cyclevar1++)); do
            tmpvar1=$(head -n $cyclevar1 $defpagesres | tail -n 1)
            tmpvar3=$(echo $tmpvar1 | sed 's/ .*//g')
            tmpvar4=$(echo $tmpvar1 | sed "s/ $tmpvar3//g" | sed 's/ .*//g')
            H=$(echo $tmpvar1 | sed "s/$tmpvar3 //g" | sed "s/$tmpvar4 //g" | sed 's/ .*//g' | sed 's/\..*//g')
            W=$(echo $tmpvar1 | sed "s/ $H//g" | sed 's/.* //g' | sed 's/\..*//g' | sed 's/ //g')
            # lets say gs gives size with screen's dpi 72, so we will increase it to desired
            gs -dNOPAUSE -dBATCH -dNOSAFER -sDEVICE=$pdfrastereng -dFirstPage=$cyclevar1 -dLastPage=$cyclevar1 -dPSFitPage -dFIXEDMEDIA -g$(($W*$pdfdpi/72))x$(($H*$pdfdpi/72)) -sOutputFile="work_dir/$cyclevar1.png" "$infile" 1>/dev/null & 
            trp
        done
        wait
        rm -f $defpagesres
    elif $(echo $infile | grep -q '.pdf')&&$(echo $inargs | grep -q 'pdftoppm'); then
        echo "# ... Extract all pages with pdftoppm (single proc)"
        pdftoppm -png "$infile" work_dir/
        for cyclevar1 in $(ls work_dir/ | grep '.png'); do
            mv -f work_dir/"$cyclevar1" work_dir/"$(echo $cyclevar1 | sed 's/-00//g' | sed 's/-0//g' | sed 's/-//g')"
        done
    elif $(echo $infile | grep -q '.pdf')&&$(echo $inargs | grep -q 'inkscape'); then
        echo "# ... Extract all pages with inkscape"
        procscount=0
        for ((cyclevar1=1; cyclevar1<=$pages; cyclevar1++)); do
            inkscape --export-filename=work_dir/$cyclevar1.png --pdf-page=$cyclevar1 $infile &
            trp
        done
        wait
    elif $(echo $infile | grep -q '.djv'); then
        djvuextr(){
            ddjvu -format=ppm -page=$cyclevar1 $infile > work_dir/$cyclevar1.ppm
            convert $limits work_dir/$cyclevar1.ppm work_dir/$cyclevar1.png
            rm -f work_dir/$cyclevar1.ppm
            }
        for ((cyclevar1=1; cyclevar1<=$pages; cyclevar1++)); do
            djvuextr &
            trp
        done
    fi
fi

## End of extract stage
#######################
## Filter stage

if ($(echo $inargs | grep -vq 'stage-'))||($(echo $inargs | grep -q 'stage-filter')); then
    echo "# Filter stage"
    
    #if $(echo $inargs | grep -q 'rotate='); then
        echo "# ... Rotate pages"
        c_t_c '' '6'
        rm -fr work_dir/rotated
        mkdir work_dir/rotated
        frot(){
            convert $limits $cyclevar1 -rotate $rotate work_dir/rotated/$(echo $cyclevar1 | sed 's/.*\///g') 2>/dev/null
            mv -f work_dir/rotated/$(echo $cyclevar1 | sed 's/.*\///g') $cyclevar1
            }
        procscount=0
        for cyclevar1 in work_dir/*.png; do
            frot &
            trp
        done
        wait
        rm -fr work_dir/rotated
    #fi
    
    if $(echo $inargs | grep -q 'magick='); then
        echo "# ... Apply a custom imagemagick filters to pages"
        c_t_c '' ''
        rm -fr work_dir/magick
        mkdir work_dir/magick
        mkdir work_dir/magick/original
        filters=$(echo $inargs | sed 's/.*magick=\[//g' | sed 's/\].*//g')
        procscount=0
        for cyclevar1 in work_dir/*.png; do
            mv -f $cyclevar1 work_dir/magick/original/$(echo $cyclevar1 | sed 's/.*\///g')
            magickrun="magick $limits work_dir/magick/original/$(echo $cyclevar1 | sed 's/.*\///g') $filters $cyclevar1 2>/dev/null &"
            eval "$magickrun"
            trp
        done
        wait
    fi
    
    if $(echo $inargs | grep -q 'split2p'); then
        echo "# ... Split double pages to single"
        c_t_c '' '6'
        rm -fr work_dir/split
        mkdir work_dir/split
        mkdir work_dir/split/original
        if $(echo $inargs | grep -q 'split2p='); then
            overlap=$(echo $inargs | sed 's/.*split2p=//g' | sed 's/ .*//g')
        else
            overlap=0
        fi
        split_func(){
            tmpvar1=$(identify $cyclevar1 | sed 's/.*PNG //g' | sed 's/ .*//g')
            W=$(echo $tmpvar1 | sed 's/x.*//g')
            H=$(echo $tmpvar1 | sed 's/.*x//g')
            if [ $W -gt $H ]; then
                convert $limits $cyclevar1 -crop $((($W/2)+$overlap))x$H+0+0 +repage work_dir/split/$(($(echo $cyclevar1 | sed 's/.*\///g' | sed 's/\..*//g')*2-1)).png 2>/dev/null
                convert $limits $cyclevar1 -crop $((($W/2)+$overlap))x$H+$((($W/2)-$overlap))+0 +repage work_dir/split/$(($(echo $cyclevar1 | sed 's/.*\///g' | sed 's/\..*//g')*2)).png 2>/dev/null
            else
                convert $limits $cyclevar1 -crop "$W"x"$((($H/2)+$overlap))"+0+0 +repage work_dir/split/$(($(echo $cyclevar1 | sed 's/.*\///g' | sed 's/\..*//g')*2-1)).png 2>/dev/null
                convert $limits $cyclevar1 -crop "$W"x"$((($H/2)+$overlap))"+0+$((($H/2)-$overlap)) +repage work_dir/split/$(($(echo $cyclevar1 | sed 's/.*\///g' | sed 's/\..*//g')*2)).png 2>/dev/null
            fi
            mv $cyclevar1 "$(echo $cyclevar1 | sed 's/work_dir/work_dir\/split\/original/g')"
        }
        for cyclevar1 in work_dir/*.png; do
            split_func &
            trp
        done
        wait
        for cyclevar1 in work_dir/split/*.png; do
            mv $cyclevar1 "$(echo $cyclevar1 | sed 's/split\///g')"
        done
    fi
    
    glue_func(){
        rm -fr work_dir/glued
        mkdir work_dir/glued
        mkdir work_dir/glued/original
        glue_subfunc(){
            tmpvar1=$(identify $leftpage | sed 's/.*PNG //g' | sed 's/ .*//g')
            W=$(echo $tmpvar1 | sed 's/x.*//g')
            H=$(echo $tmpvar1 | sed 's/.*x//g')
            if [ "$rightpage" == "" ]; then
                rightpage='work_dir/rightpage.png'
                convert $limits -size "$W"x"$H" xc: $rightpage 2>/dev/null
            fi
            if [ $W -lt $H ]; then
                montage $limits $leftpage $rightpage -tile 2x1 -geometry +0+0 work_dir/glued/$(($(echo $countvar1 | sed 's/.*\///g' | sed 's/\..*//g')/2)).png 2>/dev/null
            else
                montage $limits $leftpage $rightpage -tile 1x2 -geometry +0+0 work_dir/glued/$(($(echo $countvar1 | sed 's/.*\///g' | sed 's/\..*//g')/2)).png 2>/dev/null
            fi
            mv $leftpage "$(echo $leftpage | sed 's|\/0|\/|g' | sed 's|\/0|\/|g' | sed 's|\/0|\/|g' | sed 's|\/0|\/|g' | sed 's/work_dir/work_dir\/glued\/original/g')"
            mv $rightpage "$(echo $rightpage | sed 's|\/0|\/|g' | sed 's|\/0|\/|g' | sed 's|\/0|\/|g' | sed 's|\/0|\/|g'| sed 's/work_dir/work_dir\/glued\/original/g')"
        }
        ## rename files for make right gluing
        for cyclevar1 in work_dir/*.png; do
            printf -v out_file_name "%05d" $(echo $cyclevar1 | sed 's/.*\///g' | sed 's/.png//g') # add extra zeros
            mv -f $cyclevar1 work_dir/$out_file_name.png
        done
        countvar1=0
        for cyclevar1 in work_dir/*.png; do
            countvar1=$(($countvar1+1))
            if [ "$(($countvar1%2))" -eq 0 ]; then
                rightpage=$cyclevar1
                glue_subfunc &
            else
                leftpage=$cyclevar1
            fi
            trp
        done
        if [ "$(($countvar1%2))" -gt 0 ]; then
            countvar1=$(($countvar1+1))
            rightpage=''
            glue_subfunc &
        fi
        wait
        for cyclevar1 in work_dir/glued/*.png; do
            mv -f $cyclevar1 "$(echo $cyclevar1 | sed 's/glued\///g')"
        done
    }
    booklet_func(){
        rm -fr work_dir/bklsort
        mkdir work_dir/bklsort
        countvar1=0
        for cyclevar1 in work_dir/*.png; do
            printf -v out_file_name "%05d" $(echo $cyclevar1 | sed 's/.*\///g' | sed 's/.png//g') # add extra zeros
            mv -f $cyclevar1 work_dir/bklsort/$out_file_name.png
            countvar1=$(($countvar1+1))
        done
        
        if [ "$(($countvar1%4))" -gt 0 ]; then
            cyclevar1=$(echo @$(ls work_dir/bklsort/ | sort | tail -n 1) | sed 's/@0/@/g' | sed 's/@0/@/g' | sed 's/@0/@/g' | sed 's/@0/@/g' | sed 's/@//g' | sed 's/.png//g')
            tmpvar1=$(identify work_dir/bklsort/$out_file_name.png | sed 's/.*PNG //g' | sed 's/ .*//g')
            W=$(echo $tmpvar1 | sed 's/x.*//g')
            H=$(echo $tmpvar1 | sed 's/.*x//g')
            for ((cyclevar2=1;cyclevar2<="$((4-($countvar1%4)))";cyclevar2++)); do
                printf -v out_file_name "%05d" "$(($cyclevar1+$cyclevar2))" # add extra zeros
                convert $limits -size "$W"x"$H" xc: work_dir/bklsort/$out_file_name.png 2>/dev/null
            done
        fi
        pagelist=$(mktemp work_dir/bklsort/XXXXXX.tmp)
        countvar1=0
        for cyclevar1 in work_dir/bklsort/*.png; do
            echo $cyclevar1 >> $pagelist
            countvar1=$(($countvar1+1))
        done
        for ((cyclevar1=1;cyclevar1<=$(($countvar1/2));cyclevar1+=2)); do
            cp $(echo $(tail -n +$(($countvar1+1-$cyclevar1)) $pagelist | head -n 1)) work_dir/$((2*$cyclevar1-1)).png
            cp $(echo $(head -n $cyclevar1 $pagelist | tail -n 1)) work_dir/$((2*$cyclevar1)).png
            cp $(echo $(head -n $(($cyclevar1+1)) $pagelist | tail -n 1)) work_dir/$((2*$cyclevar1+1)).png
            cp $(echo $(tail -n +$(($countvar1-$cyclevar1)) $pagelist | head -n 1)) work_dir/$((2*$cyclevar1+2)).png
        done
    }
    
    
    if $(echo $inargs | grep -q 'glue2p'); then
        echo "# ... Glue single pages to double"
        c_t_c '' ''
        glue_func
    elif $(echo $inargs | grep -q 'booklet'); then
        echo "# ... Make simple booklet"
        c_t_c '' ''
        echo "# ... ... Resort pages"
        booklet_func
        echo "# ... ... Glue pages"
        glue_func
    elif $(echo $inargs | grep -q 'cbook'); then
        echo "# ... Make complex booklet"
        c_t_c '' ''
        if $(echo $inargs | grep -q 'cbook='); then
            period=$(echo $inargs | sed 's/.*cbook=//g' | sed 's/ .*//g')
        else
            period=16
        fi
        rm -fr work_dir/cbooklet
        mkdir work_dir/cbooklet
        mkdir work_dir/cbooklet/orig
        for cyclevar1 in work_dir/*.png; do
            printf -v out_file_name "%05d" $(echo $cyclevar1 | sed 's/.*\///g' | sed 's/.png//g') # add extra zeros
            mv -f $cyclevar1 work_dir/cbooklet/orig/$out_file_name.png
        done
        countvar2=0
        countvar3=0
        for cyclevar3 in work_dir/cbooklet/orig/*.png; do
            tmpvar2=$(echo $cyclevar3 | sed 's/.*\/0/@0/g' | sed 's/.*@0/@/g' | sed 's/@0/@/g' | sed 's/.*@0/@/g' | sed 's/.*@0/@/g' | sed 's/@//g')
            cp $cyclevar3 work_dir/$tmpvar2
            countvar2=$(($countvar2+1))
            if [ "$countvar2" -eq "$period" ]; then
                echo "# ... ... Resort pages"
                booklet_func
                echo "# ... ... Glue pages"
                glue_func
                countvar2=0
                for cyclevar4 in work_dir/*.png; do
                    countvar3=$(($countvar3+1))
                    mv -f $cyclevar4 work_dir/cbooklet/$countvar3.png
                done
            fi
        done
        if $(ls work_dir/ | grep -q '.png'); then
            echo "# ... ... Resort pages"
            booklet_func
            echo "# ... ... Glue pages"
            glue_func
            for cyclevar4 in work_dir/*.png; do
                countvar3=$(($countvar3+1))
                mv -f $cyclevar4 work_dir/cbooklet/$countvar3.png
            done
        fi
        echo "# ... ... Move pages"
        for cyclevar1 in work_dir/cbooklet/*.png; do
            mv -f $cyclevar1 work_dir/$(echo $cyclevar1 | sed 's/.*\///g')
        done
    fi
    
    if $(echo $inargs | grep -q 'room='); then
        echo "# ... Make extra 'room' for manual pages insert"
        c_t_c '' '1'
        rm -fr work_dir/room
        mkdir work_dir/room
        mkdir work_dir/room/original
        startpage=$(echo $inargs | sed 's/.*room=//g' | sed 's/-.*//g')
        freecount=$(echo $inargs | sed "s/.*room=$startpage-//g" | sed 's/ .*//g')
        
        for cyclevar1 in $(echo $(ls work_dir | grep '.png' | sort -n)); do
            countvar1=$(echo $cyclevar1 | sed 's/.*\///g' | sed 's/.png//g')
            if [ "$countvar1" -ge "$startpage" ]; then
                mv -f work_dir/$cyclevar1 work_dir/room/original/$(($countvar1+$freecount+0)).png
            else
                mv -f work_dir/$cyclevar1 work_dir/room/original/$countvar1.png
            fi
        done
        for cyclevar1 in work_dir/room/original/*.png; do
            mv -f $cyclevar1 work_dir/$(echo $cyclevar1 | sed 's/.*\///g')
        done
    fi
    
    
fi

## End of filter stage
#######################
## Mux stage

if ($(echo $inargs | grep -vq 'stage-'))||($(echo $inargs | grep -q 'stage-mux')); then
    
    echo "# Mux stage"
    c_t_c '' '3'
    if $(echo $outfile | grep -q '.djv'); then
        echo "# ... Prepare pages for conversion"
        procscount=0
        for cyclevar1 in work_dir/*.png; do
            if $(identify $cyclevar1 | grep -vq Gray)||$(echo $inargs | grep -q force-photo); then
                magick $limits $cyclevar1 work_dir/$(echo $cyclevar1  | sed 's|.*\/||g').ppm 2>/dev/null &
            else
            ## conversion to pbm may eats a lot of RAM
                magick $limits $cyclevar1 work_dir/$(echo $cyclevar1  | sed 's|.*\/||g').pbm 2>/dev/null &
            fi
            trp
        done
        wait

        if $(ls work_dir/ | grep -q '.ppm'); then
            echo "# ... Process *.ppm > *.djvu"
            procscount=0
            for cyclevar1 in work_dir/*.ppm; do
                #cpaldjvu $cyclevar1 $(echo $cyclevar1  | sed 's|.*\/||g').djvu &
                c44 $cyclevar1 work_dir/$(echo $cyclevar1  | sed 's|.*\/||g').djvu &
                trp
            done
            wait
        fi
        if $(ls work_dir/ | grep -q '.pbm'); then
            echo "# ... Process *.pbm > *.djvu"
            procscount=0
            for cyclevar1 in work_dir/*.pbm; do
                cjb2 $cyclevar1 -losslevel 200 work_dir/$(echo $cyclevar1  | sed 's|.*\/||g').djvu &
                trp
            done
            wait
        fi
        
        echo "# ... Assemble book from single djvu pages"
        first_ok=''
        for cyclevar1 in $(echo $(ls work_dir | grep djvu | sort -n)); do
            if [ "$first_ok" == "" ]; then
                cp work_dir/$cyclevar1 $outfile
                first_ok=1;
            else
                djvm -i $outfile work_dir/$cyclevar1
            fi
        done
    elif $(echo $outfile | grep -q '.pdf'); then
        procscount=0
        echo "# ... Prepare pages for conversion"
        if $(echo $inargs | grep -q potrace); then
            for cyclevar1 in work_dir/*.png; do
                ## conversion to pbm may eats a lot of RAM
                if $(identify $cyclevar1 | grep -vq Gray)||$(echo $inargs | grep -q force-photo); then
                    magick $limits $cyclevar1 work_dir/$(echo $cyclevar1  | sed 's|.*\/||g').ppm 2>/dev/null &
                else
                    ## conversion to pbm may eats a lot of RAM
                    magick $limits $cyclevar1 work_dir/$(echo $cyclevar1  | sed 's|.*\/||g').pbm 2>/dev/null &
                fi
                trp
            done
            wait
            echo "# ... Convert *.ppm > *.pdf"
            procscount=0
            for cyclevar1 in work_dir/*.ppm; do
                magick $limits $cyclevar1 work_dir/$(echo $cyclevar1  | sed 's|.*\/||g').pdf 2>/dev/null &
                trp
            done
            wait
            echo "# ... Trace *.pbm > *.pdf"
            procscount=0
            for cyclevar1 in work_dir/*.pbm; do
                potrace -b pdf "work_dir/$(echo $cyclevar1  | sed 's|.*\/||g')" -o work_dir/$(echo $cyclevar1  | sed 's|.*\/||g').pdf  &
                trp
            done
            wait
            echo "# ... Assemble pdf file"
            cd work_dir
            gs -o "../$outfile" -sDEVICE=pdfwrite -dNOPAUSE -dPDFFitPage -dNumRenderingThreads=$procs -sPAPERSIZE=a4 $(echo $(ls | grep '.pdf' | sort -n)) 1>/dev/null
            cd ../
        else
            procscount=0
            for cyclevar1 in work_dir/*.png; do
                magick $limits $cyclevar1 work_dir/$(echo $cyclevar1  | sed 's|.*\/||g').pdf 2>/dev/null &
                trp
            done
            wait
            echo "# ... Assemble pdf file"
            cd work_dir
            gs -o "../$outfile" -sDEVICE=pdfwrite -dNOPAUSE -dPDFFitPage -dNumRenderingThreads=$procs -sPAPERSIZE=a4 $(echo $(ls | grep '.pdf' | sort -n)) 1>/dev/null
            #convert $(echo $(ls | grep '.png' | sort -n)) "../$outfile" 2>/dev/null
            cd ../
            
        fi
    fi

fi

## End of mux stage
#######################
